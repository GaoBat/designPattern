# designPattern
## java设计模式
## 编程设计模式六大原则
开闭原则（Open Close Principle）:对扩展开放,对修改关闭.在程序需要进行拓展的时候,不能去修改原有的代码,实现一个热插拔的效果.简言之,是为了使程序的扩展性好,易于维护和升级.想要达到这样的效果,我们需要使用接口和抽象类,后面的具体设计中我们会提到这点.  
里氏代换原则（Liskov Substitution Principle）:里氏代换原则是面向对象设计的基本原则之一. 里氏代换原则中说,任何基类可以出现的地方,子类一定可以出现.LSP是继承复用的基石,只有当派生类可以替换掉基类,且软件单位的功能不受到影响时,基类才能真正被复用,而派生类也能够在基类的基础上增加新的行为.里氏代换原则是对开闭原则的补充.实现开闭原则的关键步骤就是抽象化,而基类与子类的继承关系就是抽象化的具体实现,所以里氏代换原则是对实现抽象化的具体步骤的规范.  
依赖倒转原则（Dependence Inversion Principle）:这个原则是开闭原则的基础,具体内容:针对接口编程,依赖于抽象而不依赖于具体.  
接口隔离原则（Interface Segregation Principle）:使用多个隔离的接口,比使用单个接口要好.它还有另外一个意思是:降低类之间的耦合度.由此可见,其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想,它强调降低依赖,降低耦合.  
迪米特法则,又称最少知道原则（Demeter Principle）:一个实体应当尽量少地与其他实体之间发生相互作用,使得系统功能模块相对独立.  
合成复用原则（Composite Reuse Principle）:尽量使用合成/聚合的方式,而不是使用继承.  
### 创建模式
创建型模式(creational pattern)对类的实例化过程进行了抽象,能够将软件模块中对象的创建和对象的使用分离.  
为了使软件的结构更加清晰,外界对于这些对象只需要知道它们共同的接口,而不清楚其具体的实现细节,使整个系统的设计更加符合单一职责原则.  
创建型模式在创建什么(What),由谁创建(Who),何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性.  
创建型模式隐藏了类的实例的创建细节,通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的.  
#### 1.singleton单例模式(懒汉/饿汉)
保证一个类只有一个实例,并提供一个访问它的全局访问点
单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。如： 
1.需要频繁实例化然后销毁的对象。 
2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 
3.有状态的工具类对象。 
4.频繁访问数据库或文件的对象。 
以下都是单例模式的经典使用场景： 
1.资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。 
2.控制资源的情况下，方便资源之间的互相通信。如线程池等。
#### 2.factory工厂模式(工厂方法/抽象方法)
工厂模式的主要功能就是帮助我们实例化对象,new时可以考虑是否使用工厂模式
如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择
将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式;
需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量
有利于消除对象间的耦合，提供更大的灵活性
当创建对象逻辑比较复杂时，可以考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。下面两种情况可视为创建逻辑复杂
类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况。
考虑使用工厂模式，将这一大坨 if-else创建对象的代码抽离出来，放到工厂类中。
尽管不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如要组合其他类对象，做各种初始化操作。
在这种情况下，也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。
对于第一种情况，当每个对象的创建逻辑都比较简单的时候，推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。
当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。
同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，建议使用工厂方法模式。
置于抽象工厂模式，使用场景不多。如果碰到一个工厂需要承担多种不同类型的对象创建时，可以考虑使用

#### 3.builder(建造者)
汽车由车轮 方向盘 发动机很多部件组成,同时,将这些部件组装成汽车也是一件复杂的工作,将一个复杂对象的构建与它的表示分离
builder模式就是将这两种情况分开进行
代码量变多,但是可读性和可维护性更友好
https://blog.csdn.net/xu404741377/article/details/73699523?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-73699523-blog-115385606.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-73699523-blog-115385606.pc_relevant_default&utm_relevant_index=2

#### 4.prototype(原型)
用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象
(1)类初始化需要消化非常多的资源,这个资源包括数据、硬件资源等,通过原型拷贝避免这些消耗。
(2)通过new一个对象需要非常繁琐的数据准备或访问权限,可以使用原型模式。
(3)一个对象需要提供给其他对象访问,而且各个调用者可能需要修改其值,可以考虑使用原型模式拷贝多个对象供调用者使用,即保护性拷贝

#### 结构模式
关注于对象的组成以及对象之间依赖关系,描述如何将类或者对象结合在一起形成更大的结构
就像搭积木,可以通过简单积木的组合形成复杂的;功能更为强大的结构
#### 5.adapter(适配器)
使用类再生的两个方式:组合和继承
将两个不兼容的类纠合在一起使用，属于结构型模式,需要有 Adaptee(被适配者)和 Adaptor(适配器)两个身份
适配器模式的应用场景:
适配器模式（Adapter Pattern）是指将一个类的接口转换成客户期望的另一个接口，使原本的接口不兼容的类可以一起工作，属于结构型设计模式。
适配器适用于以下几种业务场景：
1、已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。
2、适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。有点亡羊补牢的感觉。
生活中也非常的应用场景，例如电源插转换头、手机充电转换头、显示器转接头。

#### 6.proxy(代理)
代理(proxy)是一种设计模式,提供了对目标对象另外的访问方式:即通过代理对象访问目标对象
这样的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能
这里使用到编程中的一个思想:不要随意去改变别人已经写好的代码或者方法
如果需要修改,可以通过代理的方式来扩展该方法

静态代理
在某种情况下,客户类不能直接引用目标对象,需要通过代理对象去引用
一般的代理对象都会有一个接口
代理对象和目标对象共同实现这个接口
静态代理(继承、实现接口)和动态代理(基于接口的jdk动态代理,不基于接口的cglib动态代理)

#### 7.facade(门面)

#### 8.composite(组合)

#### 9.decorator(装饰器)

#### 10.bridge(桥连)

#### 11.flyweight(共享元)

#### 行为模式
关注于对象的行为问题,是对在不同的对象之间划分责任和算法的抽象化,不仅仅关注类和对象的结构,而且重点关注它们之间的相互作用
#### 12.command(命令)

#### 13.observer(观察者)

#### 14.iterator(迭代器模式)
这个模式已经被整合入java的Collection,在大多数场合下无需自己创造一个Iterator,只要将对象装入Collection中,
直接使用Iterator进行对象遍历

#### 15.template(模板方法)

#### 16.strategy(策略)
不同算法各自封装,用户端可以随意挑选需要的算法

#### 17.chain of responsibility(职责链)
各司其职的类串成一串,如果自己能完成则不推委下一个

#### 18.Mediator(中介)

#### 19.state(状态)
状态是编程中经常遇到的实例,将状态对象化,设立状态变换器,便可在状态中轻松切换

#### 20.memento(备忘录)
很简单的一个模式,就是在内存中保留原来数据的拷贝

#### 21.interpreter(解释器)
主要用来对语言的分析,应用机会不多

#### 22.vistor(访问者)
访问者在进行访问时,完成一系列实质性的操作,而且还可以扩展